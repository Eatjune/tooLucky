[1,["3eGST87glBj5rHwU/VF0jU"],["_effectAsset"],[["cc.EffectAsset",["_name","shaders","techniques"],0],["cc.Material",["_name","_techniqueData"],1]],[[0,0,1,2,4],[1,0,1,3]],[[[[0,"lcc-2d_outline",[{"hash":4263920246,"record":null,"name":"lcc-2d_outline|vs|fs","glsl3":{"vert":"\n  precision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\n  in vec3 a_position;\n  #if USE_TEXTURE\n  in vec2 a_uv0;\n  out vec2 uv0;\n  #endif\n  #if ATTR_UVRECT\n  in vec4 a_uvrect;\n  out vec4 uvrect;\n    #elif UNIF_UVRECT\n  uniform UNIF_UVRECT {\n    vec4 u_uvrect;\n  };\n  out vec4 uvrect;\n  #else\n  vec4 D_uvrect = vec4(0.0,0.0,1.0,1.0);\n  out vec4 uvrect;\n  #endif\n  #if ATTR_COLOR\n  in vec4 a_color;\n  out vec4 color;\n    #elif UNIF_COLOR\n  uniform UNIF_COLOR {\n    vec4 u_color;\n  };\n  out vec4 color;\n  #else\n  vec4 D_color = vec4(1.0,1.0,1.0,1.0);\n  out vec4 color;\n  #endif\n  #if ATTR_OUTLINECOLOR\n  in vec4 a_outlineColor;\n  out vec4 outlineColor;\n    #elif UNIF_OUTLINECOLOR\n  uniform UNIF_OUTLINECOLOR {\n    vec4 u_outlineColor;\n  };\n  out vec4 outlineColor;\n  #else\n  vec4 D_outlineColor = vec4(1.0,1.0,1.0,1.0);\n  out vec4 outlineColor;\n  #endif\n  #if ATTR_OUTLINEWIDTH\n  in float a_outlineWidth;\n  out float outlineWidth;\n    #elif UNIF_OUTLINEWIDTH\n  uniform UNIF_OUTLINEWIDTH {\n    float u_outlineWidth;\n  };\n  out float outlineWidth;\n  #else\n  float D_outlineWidth = 0.03;\n  out float outlineWidth;\n  #endif\n  #if ATTR_GLOWFLASH\n  in float a_glowFlash;\n  out float glowFlash;\n    #elif UNIF_GLOWFLASH\n  uniform UNIF_GLOWFLASH {\n    float u_glowFlash;\n  };\n  out float glowFlash;\n  #else\n  float D_glowFlash = 0.0;\n  out float glowFlash;\n  #endif\n  void main () {\n    vec4 pos = vec4(a_position, 1);\n    #if CC_USE_MODEL\n    pos = cc_matViewProj * cc_matWorld * pos;\n    #else\n    pos = cc_matViewProj * pos;\n    #endif\n  #if USE_TEXTURE\n  uv0 = a_uv0;\n  #endif\n  #if ATTR_UVRECT\n  uvrect = a_uvrect;\n    #elif UNIF_UVRECT\n    uvrect = u_uvrect;\n    #else\n    uvrect = D_uvrect;\n  #endif\n  #if ATTR_COLOR\n  color = a_color;\n    #elif UNIF_COLOR\n    color = u_color;\n    #else\n    color = D_color;\n  #endif\n  #if ATTR_OUTLINECOLOR\n  outlineColor = a_outlineColor;\n    #elif UNIF_OUTLINECOLOR\n    outlineColor = u_outlineColor;\n    #else\n    outlineColor = D_outlineColor;\n  #endif\n  #if ATTR_OUTLINEWIDTH\n  outlineWidth = a_outlineWidth;\n    #elif UNIF_OUTLINEWIDTH\n    outlineWidth = u_outlineWidth;\n    #else\n    outlineWidth = D_outlineWidth;\n  #endif\n  #if ATTR_GLOWFLASH\n  glowFlash = a_glowFlash;\n    #elif UNIF_GLOWFLASH\n    glowFlash = u_glowFlash;\n    #else\n    glowFlash = D_glowFlash;\n  #endif\n    gl_Position = pos;\n  }","frag":"\n  precision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\n  #if USE_TEXTURE\n  uniform sampler2D texture;\n  #endif\n  #if USE_TEXTURE\n  in vec2 uv0;\n  #endif\n  in vec4 uvrect;\n  in vec4 color;\n  in vec4 outlineColor;\n  in float outlineWidth;\n  in float glowFlash;\nfloat getBgAlpha() {\n  vec2 ruv0 =\n  vec2((uv0.x - uvrect[0]) / uvrect[2], (uv0.y - uvrect[1]) / uvrect[3]);\n  vec2 ofsuv = ruv0 + vec2(0, outlineWidth);\n  vec4 color_up = texture(texture,\n  vec2(uvrect[0] + ofsuv.x * uvrect[2], uvrect[1] + ofsuv.y * uvrect[3]));\n  ofsuv = ruv0 - vec2(0, outlineWidth);\n  vec4 color_down = texture(texture,\n  vec2(uvrect[0] + ofsuv.x * uvrect[2], uvrect[1] + ofsuv.y * uvrect[3]));\n  ofsuv = ruv0 - vec2(outlineWidth, 0);\n  vec4 color_left = texture(texture,\n  vec2(uvrect[0] + ofsuv.x * uvrect[2], uvrect[1] + ofsuv.y * uvrect[3]));\n  ofsuv = ruv0 + vec2(outlineWidth, 0);\n  vec4 color_right = texture(texture,\n  vec2(uvrect[0] + ofsuv.x * uvrect[2], uvrect[1] + ofsuv.y * uvrect[3]));\n  ofsuv = ruv0 + vec2(outlineWidth, -outlineWidth);\n  vec4 color_up_left = texture(texture,\n  vec2(uvrect[0] + ofsuv.x * uvrect[2], uvrect[1] + ofsuv.y * uvrect[3]));\n  ofsuv = ruv0 + vec2(outlineWidth, outlineWidth);\n  vec4 color_up_right = texture(texture,\n  vec2(uvrect[0] + ofsuv.x * uvrect[2], uvrect[1] + ofsuv.y * uvrect[3]));\n  ofsuv = ruv0 + vec2(-outlineWidth, -outlineWidth);\n  vec4 color_down_left = texture(texture,\n  vec2(uvrect[0] + ofsuv.x * uvrect[2], uvrect[1] + ofsuv.y * uvrect[3]));\n  ofsuv = ruv0 + vec2(-outlineWidth, outlineWidth);\n  vec4 color_down_right = texture(texture,\n  vec2(uvrect[0] + ofsuv.x * uvrect[2], uvrect[1] + ofsuv.y * uvrect[3]));\n  float total = color_right.a + color_left.a + color_down.a + color_up.a + color_up_left.a + color_up_right.a + color_down_left.a + color_down_right.a;\n  return clamp(total, 0.0, 1.0);\n}\n  void main () {\n    vec4 o = vec4(1, 1, 1, 1);\n    #if USE_TEXTURE\n    o *= texture(texture, uv0);\n      #if CC_USE_ALPHA_ATLAS_TEXTURE\n      o.a *= texture2D(texture, uv0 + vec2(0, 0.5)).r;\n      #endif\n    #endif\n    o *= color;\n    ALPHA_TEST(o);\n      if (outlineWidth == 0.0) {\n        return;\n      }\n      vec4 color_dest = outlineColor * getBgAlpha();\n      vec4 color_src = o;\n  if(glowFlash <= 0.){\n    gl_FragColor = color_src * color_src.a + color_dest * (1.0 - color_src.a);\n  }else{\n    vec4 dc = abs((mod(cc_time.x, glowFlash) / glowFlash) - 0.5) * (color_dest * color_dest.a) * 2.0;\n    gl_FragColor = color_src * color_src.a + dc * (1.0 - color_src.a);\n  }\n  }"},"glsl1":{"vert":"\n  precision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\n  attribute vec3 a_position;\n  #if USE_TEXTURE\n  attribute vec2 a_uv0;\n  varying vec2 uv0;\n  #endif\n  #if ATTR_UVRECT\n  attribute vec4 a_uvrect;\n  varying vec4 uvrect;\n    #elif UNIF_UVRECT\n  uniform vec4 u_uvrect;\n  varying vec4 uvrect;\n  #else\n  vec4 D_uvrect = vec4(0.0,0.0,1.0,1.0);\n  varying vec4 uvrect;\n  #endif\n  #if ATTR_COLOR\n  attribute vec4 a_color;\n  varying vec4 color;\n    #elif UNIF_COLOR\n  uniform vec4 u_color;\n  varying vec4 color;\n  #else\n  vec4 D_color = vec4(1.0,1.0,1.0,1.0);\n  varying vec4 color;\n  #endif\n  #if ATTR_OUTLINECOLOR\n  attribute vec4 a_outlineColor;\n  varying vec4 outlineColor;\n    #elif UNIF_OUTLINECOLOR\n  uniform vec4 u_outlineColor;\n  varying vec4 outlineColor;\n  #else\n  vec4 D_outlineColor = vec4(1.0,1.0,1.0,1.0);\n  varying vec4 outlineColor;\n  #endif\n  #if ATTR_OUTLINEWIDTH\n  attribute float a_outlineWidth;\n  varying float outlineWidth;\n    #elif UNIF_OUTLINEWIDTH\n  uniform float u_outlineWidth;\n  varying float outlineWidth;\n  #else\n  float D_outlineWidth = 0.03;\n  varying float outlineWidth;\n  #endif\n  #if ATTR_GLOWFLASH\n  attribute float a_glowFlash;\n  varying float glowFlash;\n    #elif UNIF_GLOWFLASH\n  uniform float u_glowFlash;\n  varying float glowFlash;\n  #else\n  float D_glowFlash = 0.0;\n  varying float glowFlash;\n  #endif\n  void main () {\n    vec4 pos = vec4(a_position, 1);\n    #if CC_USE_MODEL\n    pos = cc_matViewProj * cc_matWorld * pos;\n    #else\n    pos = cc_matViewProj * pos;\n    #endif\n  #if USE_TEXTURE\n  uv0 = a_uv0;\n  #endif\n  #if ATTR_UVRECT\n  uvrect = a_uvrect;\n    #elif UNIF_UVRECT\n    uvrect = u_uvrect;\n    #else\n    uvrect = D_uvrect;\n  #endif\n  #if ATTR_COLOR\n  color = a_color;\n    #elif UNIF_COLOR\n    color = u_color;\n    #else\n    color = D_color;\n  #endif\n  #if ATTR_OUTLINECOLOR\n  outlineColor = a_outlineColor;\n    #elif UNIF_OUTLINECOLOR\n    outlineColor = u_outlineColor;\n    #else\n    outlineColor = D_outlineColor;\n  #endif\n  #if ATTR_OUTLINEWIDTH\n  outlineWidth = a_outlineWidth;\n    #elif UNIF_OUTLINEWIDTH\n    outlineWidth = u_outlineWidth;\n    #else\n    outlineWidth = D_outlineWidth;\n  #endif\n  #if ATTR_GLOWFLASH\n  glowFlash = a_glowFlash;\n    #elif UNIF_GLOWFLASH\n    glowFlash = u_glowFlash;\n    #else\n    glowFlash = D_glowFlash;\n  #endif\n    gl_Position = pos;\n  }","frag":"\n  precision highp float;\n#if USE_ALPHA_TEST\n  uniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nuniform vec4 cc_time;\n  #if USE_TEXTURE\n  uniform sampler2D texture;\n  #endif\n  #if USE_TEXTURE\n  varying vec2 uv0;\n  #endif\n  varying vec4 uvrect;\n  varying vec4 color;\n  varying vec4 outlineColor;\n  varying float outlineWidth;\n  varying float glowFlash;\nfloat getBgAlpha() {\n  vec2 ruv0 =\n  vec2((uv0.x - uvrect[0]) / uvrect[2], (uv0.y - uvrect[1]) / uvrect[3]);\n  vec2 ofsuv = ruv0 + vec2(0, outlineWidth);\n  vec4 color_up = texture2D(texture,\n  vec2(uvrect[0] + ofsuv.x * uvrect[2], uvrect[1] + ofsuv.y * uvrect[3]));\n  ofsuv = ruv0 - vec2(0, outlineWidth);\n  vec4 color_down = texture2D(texture,\n  vec2(uvrect[0] + ofsuv.x * uvrect[2], uvrect[1] + ofsuv.y * uvrect[3]));\n  ofsuv = ruv0 - vec2(outlineWidth, 0);\n  vec4 color_left = texture2D(texture,\n  vec2(uvrect[0] + ofsuv.x * uvrect[2], uvrect[1] + ofsuv.y * uvrect[3]));\n  ofsuv = ruv0 + vec2(outlineWidth, 0);\n  vec4 color_right = texture2D(texture,\n  vec2(uvrect[0] + ofsuv.x * uvrect[2], uvrect[1] + ofsuv.y * uvrect[3]));\n  ofsuv = ruv0 + vec2(outlineWidth, -outlineWidth);\n  vec4 color_up_left = texture2D(texture,\n  vec2(uvrect[0] + ofsuv.x * uvrect[2], uvrect[1] + ofsuv.y * uvrect[3]));\n  ofsuv = ruv0 + vec2(outlineWidth, outlineWidth);\n  vec4 color_up_right = texture2D(texture,\n  vec2(uvrect[0] + ofsuv.x * uvrect[2], uvrect[1] + ofsuv.y * uvrect[3]));\n  ofsuv = ruv0 + vec2(-outlineWidth, -outlineWidth);\n  vec4 color_down_left = texture2D(texture,\n  vec2(uvrect[0] + ofsuv.x * uvrect[2], uvrect[1] + ofsuv.y * uvrect[3]));\n  ofsuv = ruv0 + vec2(-outlineWidth, outlineWidth);\n  vec4 color_down_right = texture2D(texture,\n  vec2(uvrect[0] + ofsuv.x * uvrect[2], uvrect[1] + ofsuv.y * uvrect[3]));\n  float total = color_right.a + color_left.a + color_down.a + color_up.a + color_up_left.a + color_up_right.a + color_down_left.a + color_down_right.a;\n  return clamp(total, 0.0, 1.0);\n}\n  void main () {\n    vec4 o = vec4(1, 1, 1, 1);\n    #if USE_TEXTURE\n    o *= texture2D(texture, uv0);\n      #if CC_USE_ALPHA_ATLAS_TEXTURE\n      o.a *= texture2D(texture, uv0 + vec2(0, 0.5)).r;\n      #endif\n    #endif\n    o *= color;\n    ALPHA_TEST(o);\n      if (outlineWidth == 0.0) {\n        return;\n      }\n      vec4 color_dest = outlineColor * getBgAlpha();\n      vec4 color_src = o;\n  if(glowFlash <= 0.){\n    gl_FragColor = color_src * color_src.a + color_dest * (1.0 - color_src.a);\n  }else{\n    vec4 dc = abs((mod(cc_time.x, glowFlash) / glowFlash) - 0.5) * (color_dest * color_dest.a) * 2.0;\n    gl_FragColor = color_src * color_src.a + dc * (1.0 - color_src.a);\n  }\n  }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"ATTR_UVRECT","type":"boolean","defines":[]},{"name":"UNIF_UVRECT","type":"boolean","defines":[]},{"name":"ATTR_COLOR","type":"boolean","defines":[]},{"name":"UNIF_COLOR","type":"boolean","defines":[]},{"name":"ATTR_OUTLINECOLOR","type":"boolean","defines":[]},{"name":"UNIF_OUTLINECOLOR","type":"boolean","defines":[]},{"name":"ATTR_OUTLINEWIDTH","type":"boolean","defines":[]},{"name":"UNIF_OUTLINEWIDTH","type":"boolean","defines":[]},{"name":"ATTR_GLOWFLASH","type":"boolean","defines":[]},{"name":"UNIF_GLOWFLASH","type":"boolean","defines":[]},{"name":"CC_USE_MODEL","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"CC_USE_ALPHA_ATLAS_TEXTURE","type":"boolean","defines":["USE_TEXTURE"]}],"blocks":[{"name":"UNIF_UVRECT","binding":0,"members":[{"name":"u_uvrect","type":16,"count":1}],"defines":["UNIF_UVRECT"]},{"name":"UNIF_COLOR","binding":1,"members":[{"name":"u_color","type":16,"count":1}],"defines":["UNIF_COLOR"]},{"name":"UNIF_OUTLINECOLOR","binding":2,"members":[{"name":"u_outlineColor","type":16,"count":1}],"defines":["UNIF_OUTLINECOLOR"]},{"name":"UNIF_OUTLINEWIDTH","binding":3,"members":[{"name":"u_outlineWidth","type":13,"count":1}],"defines":["UNIF_OUTLINEWIDTH"]},{"name":"UNIF_GLOWFLASH","binding":4,"members":[{"name":"u_glowFlash","type":13,"count":1}],"defines":["UNIF_GLOWFLASH"]},{"name":"ALPHA_TEST","binding":5,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]}],"samplers":[{"name":"texture","type":29,"count":1,"binding":30,"defines":["USE_TEXTURE"]}]}],[{"passes":[{"program":"lcc-2d_outline|vs|fs","blendState":{"targets":[{"blend":true}]},"rasterizerState":{"cullMode":0},"properties":{"texture":{"value":"white","type":29},"alphaThreshold":{"type":13,"value":[0.5]}}}]}]]],0,0,[],[],[]],[[[1,"lcc-2d_outline",{"0":{"props":{"alphaThreshold":0},"defines":{"USE_TEXTURE":true,"ATTR_OUTLINEWIDTH":false,"UNIF_OUTLINEWIDTH":false,"ATTR_GLOWFLASH":false,"UNIF_GLOWFLASH":false,"UNIF_OUTLINECOLOR":false,"ATTR_OUTLINECOLOR":false,"UNIF_COLOR":false,"ATTR_COLOR":false,"ATTR_UVRECT":false,"UNIF_UVRECT":false,"USE_ALPHA_TEST":false}}}]],0,0,[0],[0],[0]]]]